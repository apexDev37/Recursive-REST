from django.core.exceptions import ImproperlyConfigured

from unittest import TestCase
from unittest.mock import call, patch

from greetings.views import (
  encode_credentials, 
  load_env_credentials,
  request_access_token,
)


TEST_CLIENT_ID: str = 'test_id'
TEST_CLIENT_SECRET: str = 'test_secret'


class AuthenticationTestCase(TestCase):
  """
  Test case to test the auth flow process to acquire an
  access token for the grant type: "client credentials".
  """
  
  def setUp(self) -> None:
    self.client_id = TEST_CLIENT_ID
    self.client_secret = TEST_CLIENT_SECRET
    self.credential = f'{self.client_id}:{self.client_secret}'
    self.encoded_credential = 'dGVzdF9pZDp0ZXN0X3NlY3JldA=='
    
  @patch('greetings.views.base64.b64encode')
  def test_should_base64_encode_the_provided_client_id_and_secret(self, mock_b64_encode) -> None:
    # Given
    # generated by script: ./utility/scripts/oauth/encoder.py
    expected = 'dGVzdF9pZDp0ZXN0X3NlY3JldA=='
    
    # When
    mock_b64_encode.return_value.decode.return_value = expected
    actual = encode_credentials(self.client_id, self.client_secret)
    
    # Then
    self.assertIsInstance(actual, str)
    mock_b64_encode.assert_called_once_with(self.credential.encode('utf-8'))
    self.assertEqual(actual, expected)
  
  @patch('greetings.views.requests')
  def test_should_provide_minimum_required_arguments_for_access_token_request(self, mock_requests) -> None:    
    # Given
    expected = {
      'url': "http://127.0.0.1:8000/o/token/",
      'headers': {
        "Content-Type": "application/x-www-form-urlencoded",
        "Authorization": f"Basic {self.encoded_credential}",
      },
      'data': {"grant_type": "client_credentials"},
    }
    
    # When
    request_access_token(self.encoded_credential)
    actual = mock_requests.post.call_args_list[0][1]
        
    # Then
    mock_requests.post.assert_called_once()
    self.assertIn('url', actual)
    self.assertEqual(actual['url'], expected['url'])

    self.assertDictContainsSubset(expected['headers'], actual['headers'])
    self.assertDictEqual(actual['data'], expected['data'])
    
  @patch('greetings.views.requests')
  def test_should_retrieve_access_token_response_from_valid_client_request(self, mock_requests) -> None:
    # Given
    expected = {
      'access_token': 'valid_access_token_from_server', 
      'expires_in': 36000, 
      'token_type': 'Bearer', 
      'scope': 'read write'
    }
    
    # When
    mock_requests.post.return_value.json.return_value = expected
    response = request_access_token(self.encoded_credential)
    actual = response.json()
    
    # Then
    mock_requests.post.assert_called_once()
    self.assertIsInstance(actual, dict)
    self.assertIn('access_token', actual)
    self.assertEqual(actual, expected)
        

class CredentialsTestCase(TestCase):
  """
  Test case to test that client credentials env 
  variables are loaded from either the host machine
  or a defined env file.
  
  Behavior: 
    Given credentials set as env variables on the host
    machine, Then load credentials from the host machine.
    
    Given credentials set in an env file, When credentials
    not found on host machine, Then read env_file and load
    client credentials.
    
    Given credentials are not set on both host machine and
    env file, Then raise semantic error to inform user to
    configure the required client credentials.
  """

  def setUp(self) -> None:
    self.client_id = TEST_CLIENT_ID
    self.client_secret = TEST_CLIENT_SECRET
  
  @patch('greetings.views.os.environ')
  def test_should_raise_exception_for_missing_credentials_on_both_host_and_env_file(self, mock_environ) -> None:
    # Given
    mock_environ.get.side_effect = [
      None, None,   # Not found on host
      None, None    # Not found in env file
    ]    
    
    # Then
    with self.assertRaises(ImproperlyConfigured):
      load_env_credentials()  # When

  @patch('greetings.views.os.environ')
  @patch('greetings.views.environ.Env', autospec=True)
  def test_should_prefer_load_client_credentials_from_host_machine(self, mock_env, mock_environ) -> None:
    # Given
    expected = {'CLIENT_ID': self.client_id, 'CLIENT_SECRET': self.client_secret}
    mock_environ.get.side_effect = [
      expected['CLIENT_ID'], expected['CLIENT_SECRET']    # Found on host
    ]
    
    # When
    actual = load_env_credentials()
    
    # Then    
    mock_env.read_env.assert_not_called()
    mock_environ.get.assert_has_calls([
      call('CLIENT_ID', None),
      call('CLIENT_SECRET', None)
    ])
    self.assertEqual(actual['CLIENT_ID'], expected['CLIENT_ID'])
    self.assertEqual(actual['CLIENT_SECRET'], expected['CLIENT_SECRET'])

  @patch('greetings.views.os.environ')
  @patch('greetings.views.environ.Env', autospec=True)
  def test_should_fallback_to_load_client_credentials_from_env_file(self,  mock_env, mock_environ) -> None:
    # Given
    expected = {'CLIENT_ID': self.client_id, 'CLIENT_SECRET': self.client_secret}
    mock_environ.get.side_effect = [
      None, None,                                         # Not found on host
      expected['CLIENT_ID'], expected['CLIENT_SECRET']    # Found in env file
    ]
    
    # When
    actual = load_env_credentials()
    
    # Then    
    mock_env.read_env.assert_called_once()
    mock_environ.get.assert_has_calls([
      call('CLIENT_ID', None), call('CLIENT_SECRET', None),   # Try load from host
      call('CLIENT_ID', None),call('CLIENT_SECRET', None)     # Try load from env file
    ])
    self.assertEqual(actual['CLIENT_ID'], expected['CLIENT_ID'])
    self.assertEqual(actual['CLIENT_SECRET'], expected['CLIENT_SECRET'])

  